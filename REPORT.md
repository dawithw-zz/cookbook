#Programmer's Guide

**Program Setup**

The program is divided into multiple object, each containing its own header file and an
associated .cpp file. Some objects are integrated into the .h and .cpp files of closely related objects, such as recipeinfo object being embedded in the recipe.h and recipe.cpp. There are 7 header files, 7 associated implementation files (.cpp), a main.cpp, 3 menu files where the menu descriptions are stored, and a makefile for compiling.

**Objects**

The save function contained in all objects (except parser) takes a reference to an output stream and writes the contents of the object to the stream. By doing this, a parent object can easily pass the output stream to the child object, which then writes its content to the stream – nested writing. The objects are all set up so that they function in a nested manner without being restricted to exist in such tree.
- **Parser:** The parser maintains an input file stream, an output file stream, a string line and a string temp_file that determines the name of the temporary file it is to use for outputting the formatted input file. The constructor requires a string parameter for determining which filename to open. This allows the constructor to open the file, read its contents and reformat it and save it into the temp_file, which is then accessed later when objects are created. Several other functions are used to create objects from the RBML file that was read. The two functions that the user can call are build_cookbook and build_inventory functions, which build cookbooks and inventories respectively. These functions call other helper functions based on the objects that need to be created. The basic format of the parser is that it has two main functions for building the two different types of files that are handled – recipe files (cookbook) and inventory files – which call other functions which then call other functions in a nested manner (similar to the way the tags are set up in the RBML).
- **Cookbook:** It stores a string title, and two vectors of type section and recipe for containing sections and recipes respectively. Using default constructor. The add function is overloaded to take in title, section object or a recipe object, which are added to their respective types. It has an addition (+=) operator overloaded for adding two cookbooks which simply merges the sections and recipes by combining the sections and recipes vectors of the two cookbooks. The title of the original is preserved. It has print and save functions which output its content to the console and file respectively.
- **Section:** The section is just a container object of recipes with a string storing its title. It has a function that allow addition of recipes to the vector container, and a function that sets its title.
- **Menu:** The menu contains a vector of recipes, for storing the multiple vectors it might contain, along with an ingredient and equipment vector that stores the combined collection of ingredients and equipments from all recipes stored. Overloaded add functions allow adding recipes, ingredients and equipments. Whenever recipes are added, their ingredients and equipments are also added to the ingredients and equipments vectors. The get function constructs an inventory from the ingredients and equipments collection, and returns it. The reset function clears all containers.
Recipe: The recipe contains a string title, serving and notes. Additionally it contains a recipeinfo object, a vector of ingredients and a preparation object. It has overloaded add function for each type of property, with the strings having an add function that takes in an additional int for determining the string to modify. The get function for equipments calls the get_equipments function of the preparation object, as all objects are stored in there. It has a print function that can be called to print its content to console. An overloaded == operator compares two recipes by their names.
- **RecipieInfo:** Has a bunch of string items that store the different properties of recipeinfo. A single add function is user for setting these items. The add function takes a string item and an int which determines which property to set the string item equal to. The Empty function determines if nothing has been initialized. Ingredient: Is made of a string name, string state and a Quantity object the contains the quantity value and unit. Two ingredients are defined to be equal, according to the == operator, when they have the same name and same state. For example: Onion == Onion (true) but Onion == Onion, diced (false). Since an ingredient in different states has different quantity per unit, it would be impractical to implement two ingredients with different states as being equal. Has overloaded += and -= functions for performing addition and subtraction between ingredient items, which perform the operation on the ingredient’s quantity object.
Quantity: It stores the quantity value and unit by taking in two strings using the add function – which takes a string and an integer to determine which property to set. The quantity value is taken as a string and is converted into an integer value that allow computation. There is a fraction “object” embedded in the quantity, which converts a string to fraction and performs operations on such fraction. String is converted to integer by checking the format, and if proper format, by reading each character and using its ascii value to build an integer. Fractions are simplified after each operation for better readability and simplicity. Additionally, large quantities of an ingredient item with a known unit will have the quantity converted into a smaller quantity of larger unit (such as 16 tbsp -> 1 cup). A bunch of Boolean variables detect the state of the fraction that allow the functions to perform the appropriate steps.
- **Unit:** It stores a string value unit. It also has the basic conversion factors in terms of teaspoon (the smallest available unit from the table). The list of constant integer variables holding the conversion factor from on unit to tsp is used to convert quantity’s value by multiplying with factor. After operation of quantities, these values are used to convert to a larger unit by division using factor. A unit string is converted into all lower case and remove “.” by using the simplify function.
- **Preparation:** Has vectors that store equipments, steps and timedsteps. A series of overloaded add functions take the different types an add them to the respective container. The print function prints each contained element in the vector by calling the object’s print function.
Step: It two string for storing the step before and after an equipment is used. Since equipments are integrated with steps in the preparation of recipes, this allows storing the structure of the step by keeping track of the position of the equipment. Add functions are used to add steps and equipments, and a Boolean variable determines to which string value is a step to be added, based on whether an equipment was added or not. The print function prints the step before, equipment and step after in order.
- **TimedStep:** It contains a step and a Steptime. It is a bridge into forming a more complex step that is associated with time determined by Steptime. It also may contain additional text value.
StepTime: Has a series of string variables for storing the different properties of steptime. An add function takes in a string value, and an integer for determining which variable is to be initialized. The empty function determines if any property has been initialized and the print function prints any initialized property to console.
- **Equipment:** This object has a string name and an integer quantity. Fractions of objects are not practical, hence integers are used. It has two save functions which determine the way it is written to the save file. Inventories will have as many equipment written as there are quantity.
- **Inventory:** It has two vectors for storing ingredients and equipments. Overloaded operations allow addition between two inventories, an subtraction of an ingredient from the inventory. The overloaded add function takes in the two types stored in inventory – ingredients and equipments – as well as the vectors of these two types. The remove function deletes an equipment from the equipments vector, and print calls the print function of each ingredient and equipment from those stored in the vector.
- **main(Proj3):** contains the implementation of the main interface. It has additional functions that help in parsing command such as command line arguments, inputs with possible spaces in them, and complicated inputs such as ingredients which can have names with spaces, fractional quantity and a string. The ingredient parser determines the end of each parameter by checking the character of each word input – strings are for name, and the first instance of an int will shift focus to quantity. Encountering a non-integer or not a division sign (/) will shift focus to unit.

**Error Handling:**
- Unspecified parameter for -i and -r : filename not included
- Invalid command line arguments.
- Bad input format, such as invalid item property/quantity/unit.
- Invalid command from user interface
- Negative quantities
- File open error : When reading from, or writing to, a file
- File format error : Unknown or misplaced tags based on expected file type

**Known Bugs**
- The program will terminate if a non-digit is entered for command.
- Commands that take in user input with possible spaced string values process other commands in the
same line as part of the input for the function – user input processing could be reimplemented.
- Negative value error displayed when trying to calculate shopping list – expected negative value but not
required error message.